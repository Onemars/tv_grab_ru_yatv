#!/usr/bin/env python3

###############################################################################
#
#    tv_grab_ru_yatv
#
#    URL:       https://github.com/gSpotx2f/tv_grab_ru_yatv
#    Depends:   Python >= 3.6
#
###############################################################################

from datetime import timedelta, datetime
import json
import os
import re
import socket
import ssl
import sys
import time
from urllib import request, parse
#import xml.sax.saxutils as xsu


def _get_http_data(
        url,
        encoding="utf-8",
        method="GET",
        post_data=None,
        send_headers_dict=None,
        proxies=None,
        try_connect_attempts=3,
        try_connect_timeout=1,
        connect_timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        ssl_unverified=False,
        error_handler=sys.stderr):
    http_body = http_code = received_headers = None
    opener_args = [request.ProxyHandler(proxies)]
    if ssl_unverified:
        opener_args.append(request.HTTPSHandler(context=ssl._create_unverified_context()))
    opener_obj = request.build_opener(*opener_args)
    for i in range(try_connect_attempts):
        try:
            conn_obj = opener_obj.open(
                request.Request(url, data=post_data, headers=send_headers_dict,
                                method=method),
                timeout=connect_timeout
            )
            received_headers = conn_obj.getheaders()
            http_code = conn_obj.status
            if http_code == 200:
                http_body = conn_obj.read().decode(encoding)
        except Exception as exception_obj:
            print(f" Connection error! {exception_obj} ( {url} )",
                file=error_handler)
        else:
            conn_obj.close()
            break
        time.sleep(try_connect_timeout)
    return http_body, http_code, received_headers


class YaTv:
    app_name = "tv_grab_ru_yatv"
    app_version = 0.2
    app_url = "https://github.com/gSpotx2f/tv_grab_ru_yatv"
    src_name = "tv.yandex.ru"
    src_url = "https://tv.yandex.ru/"
    api_url = "//tv.yandex.ru/ajax/i-tv-region/get?resource=schedule"
    http_scheme = "https:"
    site_encoding = "utf-8"
    chans_request_params = '"channelLimit":1000,"channelProgramsLimit":1,"fields":"schedules,channel,title,siteUrl,logo,originalSize,src,width,height,id,synonyms"'
    xmltv_tags_translate = {
        "date": "socialDate",
        "desc": "description",
        "category": "type",
        "country": "countries",
        "icon": "images,originalSize,src",
        "credits": "persons,name,role",
    }
    xmltv_credits = ("director", "actor", "writer",
                    "producer", "composer", "presenter")
    replace_categories_dict = {
        #1: "Other",                                # "другое"
        2: "News / Current Affairs",                # "инфо"    # "Social / Political issues / Economics"
        3: "Children's / Youth Programs",           # "детям"   # "Children's / Youth Programmes"
        4: "Soap / Melodrama / Folkloric",          # "сериалы"
        5: "Movie / drama",                         # "фильмы"
        6: "Leisure hobbies",                       # "досуг"
        7: "Sports",                                # "спорт"
        8: "Education / Science / Factual topics",  # "познавательное"
        9: "Adult movie / Drama",                   # "для взрослых"
        29139: "News / Current Affairs",            # "новости"
    }

    def __init__(self):
        self.default_prg_time_offset = 0
        self.user_region = None
        self.duration = 7
        self.start_day_offset = 0
        self.time_zone = "+03:00"
        self.chans_per_request = 3
        self.chans_logos = True
        self.chans_logos_url = None
        self.chans_logos_ext = ".jpg"
        self.additional_tags = True
        self.additional_tags_dict = {
            "date": False,
            "desc": True,
            "category": True,
            "country": False,
            "icon": True,
            "credits": False,
        }
        self.xmltv_id_suffix = ".yatv"
        self.channels_from_tvh = False
        self.tvh_channels_dir = "/home/hts/.hts/tvheadend/channel/config"
        self.replace_categories = True
        self.req_timout = 0
        self.connect_timeout = socket._GLOBAL_DEFAULT_TIMEOUT
        self.try_connect_attempts = 3
        self.try_connect_timeout = 2
        self.proxies = None
        self.ssl_unverified = False
        self.http_send_headers_dict = {
            "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:69.0) Gecko/20100101 Firefox/69.0",
        }
        self.output_handler = sys.stdout
        self.error_handler = sys.stderr
        self.channels_ids = {}
        self.channels_titles = {}
        self.progs_request_url_pattern = None

    @property
    def base_url(self):
        return f'{self.http_scheme}{self.api_url}{self.user_region and "&userRegion=" + str(self.user_region) or ""}'

    @property
    def additional_tags_req_str(self):
        return f'{",".join(self.xmltv_tags_translate[k] for k, v in self.additional_tags_dict.items() if v)},'

    @property
    def start_date(self):
        return f'{time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(round(time.time()) + self.start_day_offset*86400))}{self.time_zone}'

    @property
    def chans_request_url(self):
        return f"{self.base_url}&params={{{parse.quote(self.chans_request_params)}}}"

    def load_user_config(self, file_path):
        try:
            with open(file_path, "rt") as file_handler:
                user_config = eval(file_handler.read())
                if user_config and type(user_config) == dict:
                    for k, v in user_config.items():
                        setattr(self, k, v)
        except SyntaxError:
            print(f" Configuration file has a syntax error! ( {file_path} )",
                file=self.error_handler)
            raise
        except OSError as err_obj:
            print(f" Configuration file error! ({file_path})\n {err_obj}",
                file=self.error_handler)
            return False
        else:
            return True

    def get_channels_from_tvh(self):
        if not os.path.isdir(self.tvh_channels_dir):
            return False
        self.channels_ids.clear()
        tvh_channels = {}
        for item in os.listdir(self.tvh_channels_dir):
            file_path = os.path.join(self.tvh_channels_dir, item)
            if not os.path.isfile(file_path):
                return False
            try:
                with open(file_path, "rt") as file_handler:
                    re_obj = re.search('"name": "([^"]+)"', file_handler.read())
                    chan_name = re_obj.group(1)
                    if chan_name:
                        chan_offset = self.channels_titles.get(chan_name)
                        tvh_channels[chan_name] = chan_offset or self.default_prg_time_offset
            except OSError:
                continue
        self.channels_titles = tvh_channels
        return True

    def _open_url(self, url):
        return _get_http_data(
            url,
            encoding=self.site_encoding,
            send_headers_dict=self.http_send_headers_dict,
            proxies=self.proxies,
            try_connect_attempts=self.try_connect_attempts,
            try_connect_timeout=self.try_connect_timeout,
            connect_timeout=self.connect_timeout,
            ssl_unverified=self.ssl_unverified,
            error_handler=self.error_handler
        )[0]

    @staticmethod
    def _replace_xml_char(string):
        #return xsu.escape(string)
        if "&" in string:
            string = string.replace("&", "&amp;")
        if "<" in string:
            string = string.replace("<", "&lt;")
        if ">" in string:
            string = string.replace(">", "&gt;")
        return string

    @staticmethod
    def _time_recalc(date_str, t_offset):
        offset_obj = timedelta(hours=t_offset)
        re_obj = re.fullmatch(
            "([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})([+-][0-9]{2}):[0-9]{2}",
            date_str)
        date_obj = datetime(int(re_obj.group(1)), int(re_obj.group(2)),
                            int(re_obj.group(3)), int(re_obj.group(4)),
                            int(re_obj.group(5)), int(re_obj.group(6)))
        new_date_obj = date_obj + offset_obj
        new_tz = int(re_obj.group(7)) + t_offset
        new_tz_str = f"-{-new_tz:0>2d}:00" if (new_tz < 0) else f"+{new_tz:0>2d}:00"
        return f'{new_date_obj.strftime("%Y-%m-%dT%H:%M:%S")}{new_tz_str}'

    def _convert_prg_date(self, date_str, t_offset):
        if t_offset is None or t_offset is False:
            t_offset = self.default_prg_time_offset
        if t_offset:
            date_str = self._time_recalc(date_str, t_offset)
        re_obj = re.fullmatch(
            "([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2})([+-][0-9]{2}:[0-9]{2})",
            date_str)
        return f'{re.sub("[T:-]", "", re_obj.group(1))} {re.sub(":", "", re_obj.group(2))}'

    def _write_chan_xmltv(self, json_chan_data):
        if "channel" not in json_chan_data:
            return False
        self.output_handler.write(
            f'<channel id="{json_chan_data["channel"]["id"]}{self.xmltv_id_suffix or ""}">\n')
        if not json_chan_data["channel"]["synonyms"]:
            json_chan_data["channel"]["synonyms"].insert(
                0, json_chan_data["channel"]["title"])
        for i in json_chan_data["channel"]["synonyms"]:
            self.output_handler.write(
                f'<display-name lang="ru">{self._replace_xml_char(i)}</display-name>\n')
        if self.chans_logos:
            try:
                self.output_handler.write(
                    f'<icon src="{self.chans_logos_url}{json_chan_data["channel"]["id"]}{self.chans_logos_ext}" />\n'
                    if self.chans_logos_url else
                    f'<icon src="{self.http_scheme}{json_chan_data["channel"]["logo"]["originalSize"]["src"]}" />\n'
                )
            except KeyError:
                pass
        try:
            self.output_handler.write(f'<url>{json_chan_data["channel"]["siteUrl"]}</url>\n')
        except KeyError:
            pass
        self.output_handler.write('</channel>\n')
        return True

    def _write_tags_xmltv(self, event):
        if self.additional_tags_dict.get("desc"):
            try:
                if event["program"]["description"]:
                    self.output_handler.write(
                        f'<desc lang="ru">{self._replace_xml_char(event["program"]["description"])}</desc>\n')
            except KeyError:
                pass
        if self.additional_tags_dict.get("credits"):
            try:
                if event["program"]["persons"]:
                    event["program"]["persons"].sort(
                        key=lambda s: self.xmltv_credits.index(s["role"])
                            if s["role"] in self.xmltv_credits else 0
                    )
                    self.output_handler.write("<credits>\n")
                    for i in event["program"]["persons"]:
                        if i["role"] in self.xmltv_credits:
                            self.output_handler.write(
                                '<{0[role]}>{0[name]}</{0[role]}>\n'.format(i))
                    self.output_handler.write("</credits>\n")
            except KeyError:
                pass
        if self.additional_tags_dict.get("date"):
            try:
                if event["socialDate"]:
                    self.output_handler.write(
                        f'<date>{event["socialDate"].replace("-", "")}</date>\n')
            except KeyError:
                pass
        if self.additional_tags_dict.get("category"):
            try:
                if self.replace_categories:
                    if event["program"]["type"]["id"] in self.replace_categories_dict:
                        event["program"]["type"]["name"] = self.replace_categories_dict[event["program"]["type"]["id"]]
                if event["program"]["type"]["name"]:
                    self.output_handler.write(
                        f'<category lang="ru">{event["program"]["type"]["name"]}</category>\n')
            except KeyError:
                pass
        if self.additional_tags_dict.get("icon"):
            try:
                if event["program"]["images"]:
                    for i in event["program"]["images"]:
                        self.output_handler.write(
                            f'<icon src="{self.http_scheme}{i["originalSize"]["src"]}" />\n')
            except KeyError:
                pass
        if self.additional_tags_dict.get("country"):
            try:
                if event["program"]["countries"]:
                    for i in event["program"]["countries"]:
                        self.output_handler.write(
                            f'<country lang="ru">{i}</country>\n')
            except KeyError:
                pass

    def _write_progs_xmltv(self, json_data):
        if "schedules" not in json_data:
            return False
        for sched in json_data["schedules"]:
            if "events" not in sched:
                continue
            for event in sched["events"]:
                self.output_handler.write(
                    f'<programme start="{self._convert_prg_date(event["start"], self.channels_ids.get(str(event["channelId"])))}" stop="{self._convert_prg_date(event["finish"], self.channels_ids.get(str(event["channelId"])))}" channel="{event["channelId"]}{self.xmltv_id_suffix or ""}">\n<title lang="ru">{self._replace_xml_char(event["program"]["title"])}</title>\n')
                if self.additional_tags:
                    self._write_tags_xmltv(event)
                self.output_handler.write('</programme>\n')
        return True

    def _get_programs_data(self):
        ids_tuple = tuple(self.channels_ids.keys())
        i = 0
        while i < len(ids_tuple):
            http_data = self._open_url(
                self.progs_request_url_pattern.format(
                    parse.quote(
                        ",".join(ids_tuple[i:(i + self.chans_per_request)])
                    )
                )
            )
            if http_data:
                try:
                    json_dict = json.loads(http_data)
                except json.decoder.JSONDecodeError:
                    pass
                else:
                    yield json_dict
            i += self.chans_per_request

    def _get_channels_data(self):
        json_dict = {}
        http_data = self._open_url(self.chans_request_url)
        if http_data:
            try:
                json_dict = json.loads(http_data)
            except json.decoder.JSONDecodeError:
                pass
        return json_dict

    def _make_channels_dict(self, json_data, synonyms=False):
        channels_dict = {}
        if "schedules" not in json_data:
            return channels_dict
        if synonyms:
            for i in json_data["schedules"]:
                i["channel"]["synonyms"].insert(0, i["channel"]["title"])
                for j in i["channel"]["synonyms"]:
                    channels_dict[j.lower()] = str(i["channel"]["id"])
        else:
            channels_dict = {
                i["channel"]["title"] : str(i["channel"]["id"])
                for i in json_data["schedules"]
            }
        return channels_dict

    def _pick_channels_json(self, json_data):
        if "schedules" not in json_data:
            return None
        for json_dict in json_data["schedules"]:
            if str(json_dict["channel"]["id"]) in self.channels_ids:
                yield json_dict

    def write_config(self, config_handler=None):
        if not config_handler:
            config_handler = self.output_handler
        cfg_params = (
            "default_prg_time_offset",
            "user_region",
            "duration",
            "start_day_offset",
            "time_zone",
            "chans_per_request",
            "chans_logos",
            "chans_logos_url",
            "chans_logos_ext",
            "additional_tags",
            "additional_tags_dict",
            "xmltv_id_suffix",
            "channels_from_tvh",
            "tvh_channels_dir",
            "replace_categories",
            "proxies",
            "ssl_unverified",
        )
        channels_dict = self._make_channels_dict(self._get_channels_data())
        c, cfg_strings_list = 0, []
        for i in cfg_params:
            attr = getattr(self, i)
            cfg_strings_list.append(f'    "{i}" : ')
            if type(attr) == str:
                cfg_strings_list.append(f'"{attr:s}"')
            elif type(attr) == dict:
                cfg_strings_list.append(repr(attr).translate({
                        44: ",\n       ",   # ,
                        123: "{\n        ", # {
                        125: "\n    }",     # }
                    }))
            else:
                cfg_strings_list.append(str(attr))
            cfg_strings_list.append(",\n")
        config_handler.write(
            f'{{\n{"".join(cfg_strings_list)}    "channels_ids" : {{\n')
        for k, v in channels_dict.items():
            config_handler.write(f'        "{v}" : None,\t\t# {c + 1}. {k}\n')
            c += 1
        config_handler.write('    },\n    "channels_titles" : {},\n}\n')
        return c

    def run(self):
        progs_request_params = f'"channelLimit":{self.chans_per_request},"channelProgramsLimit":500,"fields":"availableChannels,availableChannelsIds,schedules,title,{self.additional_tags and self.additional_tags_req_str or ""}id,events,channelId,start,finish,program,name","duration":{self.duration * 86400},"start":"{self.start_date}"'
        self.progs_request_url_pattern = self.base_url + '&params={{' + parse.quote(
            progs_request_params + ',"channelIds":[{}]', safe="{}"
        ) + '}}'
        return_code = 1
        if self.channels_from_tvh:
            if not self.get_channels_from_tvh():
                print(
                    f" Path error! {self.tvh_channels_dir} not a directory or does not exists",
                    file=self.error_handler)
                return return_code
        json_chans_data = self._get_channels_data()
        if json_chans_data:
            channels_dict = self._make_channels_dict(json_chans_data, True)
            for k, v in self.channels_titles.items():
                if k.lower() in channels_dict:
                    self.channels_ids[channels_dict[k.lower()]] = v
            if not self.channels_ids:
                for k, v in channels_dict.items():
                    self.channels_ids[v] = self.default_prg_time_offset
        self.output_handler.write(
            f'<?xml version="1.0" encoding="{self.site_encoding}"?>\n<!DOCTYPE tv SYSTEM "xmltv.dtd">\n<tv source-info-url="{self.src_url}" source-info-name="{self.src_name}" source-data-url="{self.http_scheme}{self.api_url}" generator-info-name="{self.app_name}" generator-info-url="{self.app_url}">\n')
        chans_items, chans_requests = 0, 0
        for c in self._pick_channels_json(json_chans_data):
            if self._write_chan_xmltv(c):
                chans_items += 1
        if chans_items > 0:
            for j in self._get_programs_data():
                if self._write_progs_xmltv(j):
                    chans_requests += 1
                if self.req_timout:
                    time.sleep(self.req_timout)
            if chans_requests > 0:
                return_code = 0
        self.output_handler.write("</tv>\n")
        return return_code


if __name__ == "__main__":
    from argparse import ArgumentParser
    yatv = YaTv()
    default_user_config = user_config = config_handler = None
    for path in ("tv_grab_ru_yatv.cfg", "/home/hts/tv_grab_ru_yatv.cfg",
                "/etc/tv_grab_ru_yatv.cfg", "/opt/etc/tv_grab_ru_yatv.cfg"):
        if os.path.exists(path):
            default_user_config = path
            break
    arg_parser = ArgumentParser()
    arg_parser.add_argument("--config-file", action="store", type=str,
        help="Configuration file", dest="config_file")
    arg_parser.add_argument("--offset", action="store", type=int,
        help="Start offset (days)", dest="offset")
    arg_parser.add_argument("--days", action="store", type=int,
        help="Duration", dest="days")
    arg_parser.add_argument("--output", action="store", type=str,
        help="Output file", dest="output")
    arg_parser.add_argument("--configure", action="store_true",
        help="Create default configuration file", dest="configure")
    arg_parser.add_argument("--version", action="store_true",
        help="Version", dest="version")
    arg_parser.add_argument("--description", action="store_true",
        help="Description", dest="description")
    arg_parser.add_argument("--capabilities", action="store_true",
        help="Capabilities", dest="capabilities")
    arg_parser.add_argument("--quiet", action="store_true",
        help="Quiet output", dest="quiet")
    arg_parser.add_argument("--region", action="store", type=int,
        help="Region value for tv.yandex.ru", dest="region")
    args = arg_parser.parse_args()
    if args.config_file:
        user_config = args.config_file
    if args.configure:
        if args.region:
            yatv.user_region = args.region
        try:
            if user_config:
                config_handler = open(user_config, "w")
        except OSError as err_obj:
            print(f" Configuration file error! ( {user_config} )\n {err_obj}",
                file=sys.stderr)
            sys.exit(1)
        else:
            if yatv.write_config(config_handler) > 0:
                sys.exit(0)
            else:
                sys.exit(1)
    user_config = user_config or default_user_config
    if user_config:
        if not yatv.load_user_config(user_config):
            sys.exit(1)
    if args.region:
        yatv.user_region = args.region
    if args.offset:
        yatv.start_day_offset = args.offset
    if args.days:
        yatv.duration = args.days
    if args.version:
        print(yatv.app_version)
        sys.exit(0)
    elif args.description:
        print(f"Russian {yatv.src_name} ({yatv.app_name})")
        sys.exit(0)
    elif args.capabilities:
        print("baseline\nmanualconfig")
        sys.exit(0)
    if args.output:
        try:
            yatv.output_handler = open(args.output, "w")
        except OSError as err_obj:
            print(f" Output file error! ( {args.output} )\n {err_obj}",
                file=sys.stderr)
            sys.exit(1)
    sys.exit(yatv.run())
